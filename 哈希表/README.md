经常听到哈希表，同一个结果因为使用哈希表可以降低算法的时间复杂度，接下来将来整理一下哈希相关的知识。

主要围绕这几个方面介绍 👇

- 哈希概念介绍
- 哈希函数
- 哈希表
- 如何解决哈希冲突
- 哈希应用
- leetcode 经典例题

---

## 基本介绍

可能你听过散列表，散列函数，它们跟哈希表，哈希函数是一个概念。

我们也已经了解到：**数组**（寻址容易，插入和删除元素困难）和**链表**（寻址困难，插入和删除元素容易）的特点，那么面对这种情况，我们是否可以结合一下数组和链表的优势，创造出一种新的结构呢？答案是肯定的，这就是我们所要来说的**哈希表**

### 哈希概念

哈希表（hashing）是以键值的方式来存储元素，也就是说每一个数据都是以键值（key,value）的方式来存储的，关键字（key）是不可重复的，而值是对应于键的。我们可以把哈希表简单理解为一本字典，每一个键（key）是一个单词，而每一个单词都有自己对应的解释，也就是值（value）。

我个人简单理解就是哈希算法是通过哈希函数创建一个固定长度的键值表，key 和 value 是一种映射的关系，我们可以通过 key 值直接找到对应的 value，这样子就不在需要按照传统算法那种每次都去遍历整个数表，这样子实现寻址快，增删元素也容易的效果。

在哈希表中，不管是寻找、删除、增加一个新元素，时间复杂度都是 O(1)，这相对于数组和链表 O(n)就大大降低了时间复杂度。

### 哈希表以及实现方式

1、什么是哈希表？

Hash Table，也叫散列表，它是通过 hash 算法得到的，通俗点讲，就是建立一个固定长度的数组。

假设关键字为 value,那么其值存在与 hash(value)的存储位置上，不需要比较就可以直接拿到所查记录，称这个对应关系 f 为散列函数，按这个思想建立的表为散列表。

简单来说，哈希表就是一种映射关系的表，你可以根据这个映射关系由键（关键字）找到值。

2、哈希表怎么实现？

哈希表结合数组和链表的优势，创造一种聪明的实现方式：“拉链法”，可以简单理解为“一堆由链表组成的数组”，如果所示：

![](../images/hash%E5%AE%9E%E7%8E%B0%E5%9B%BE%E8%A7%A3.png)

有上图可以看到：哈希表的左侧是数组，数组的每一个成员包括一个指针，指向一个链表的头节点，当然链表也可能为空，也可能连接多个节点。

我们存储键值对（key-value pair）的方式主要是依靠键的特征，通过键的**哈希值**找到对应的数组下标，然后将其键值对添加到对应的链表中，寻找元素时，也会根据其键的哈希值，找到特定链表其对应的值。

这么一说，哈希值就是创建哈希表的一个重要点，那么我们应该怎么获得所谓的哈希值呢？

> 哈希表使用哈希函数将键（key）转换为一个哈希值（整型数字），然后将该数组对数组长度取余，取余得到的数字就当做数组的下标，然后将其键值对添加到对应的链表中。寻找一个键所对应的值时，我们也是使用哈希函数将键转换为对应的数组下标，并在其链表中定位到该关键字所对应的数值。

### 哈希函数（Hash Function）

> 简单来说，我们输入关键字 x，使用哈希函数 f(x)计算出哈希值 y，然后使用哈希值 y 来找特定的数组下标，并在对应位置插入新数据。在之后的实现中，我们会使用 Java 来实现哈希表，而 JVM 自动生成哈希值，我们只需要再将其哈希值和我们的哈希表数组长度取模（mod）就能拿到其对应下标。

哈希表能快速添加和查找元素的核心原因是哈希函数，哈希函数能快速将一个数值转换为哈希（整数）。所以哈希表必须保持哈希值的计算一致，实质上是一种映射的关系。如果两个哈希值是不同的，那么这两个哈希值的原始输入也是不同的。

如果两个原始值是不同的，通过 hash 算法得到相同的哈希值，此时只有一个存储空间，这种情况就是哈希冲突。

### 如何解决哈希冲突

解决方法有哪些呢 👇

- 链地址法
- 开放地址法

**链地址法**

每个数组单元中储存的不再是单个数据，而是一个链条，用的更多，java 的
HashMap，它解决 hash 冲突使用就是链地址法。

**开放地址法**

这种思路解决冲突的思路 👉**寻找空白的单元格来添加重复的数据**

那么这种方法有具体的探测三种方法 👇

- 线性试探法
- 二次探测
- 再哈希法

---

**线性探测法**

线性探测法的地址增量 di = 1, 2, ... , m-1，其中，i 为探测次数。该方法一次探测下一个地址，知道有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。

**二次探测**

二次探测法的地址增量序列为 di = 2， -4， 8， -16，… ， q^2, -q^2 (q <= m/2)。二次探测能有效避免“聚集”现象，但是不能够探测到哈希表上所有的存储单元，但是至少能够探测到一半。

**再哈希法**

把关键字用另外一个哈希函数，再做一次哈希化，用这次哈希化的结果作为步长。

**建立公共溢出区**

将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表(注意：在这个方法里面是把元素分开两个表来存储)。

### LeetCode 经典例题

- [两数之和 ⭐](https://leetcode-cn.com/problems/two-sum/)
- [有效的字母异位词 ⭐](https://leetcode-cn.com/problems/valid-anagram/)
- [无重复字符的最长子串 ⭐⭐](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
- [前 K 个高频单词 ⭐⭐](https://leetcode-cn.com/problems/top-k-frequent-words/)
- [原子的数量 ⭐⭐⭐](https://leetcode-cn.com/problems/number-of-atoms/)

---

**两数之和**
leetCode 链接(https://leetcode-cn.com/problems/two-sum/)

这道题是要求：

> 输入：nums = [2,7,11,15], target = 9
> 输出：[0,1]
> 解释：因为 nums[0] + nums[1] == 9
> 返回 [0, 1]

可以直接使用暴力解法，时间复杂度为 O(n^2)。考虑到哈希表是一种存在映射关系的数组，因此可以使用 Map 建立一种映射关系，全部 nums 中的值存入哈希表中，作为键（key），然后 target-nums[i]作为 value，使得两者的值之和为 target 的时候就返回对应两个值的下标

---

**有效的字母异位词**
LeetCode 链接(https://leetcode.cn/problems/valid-anagram/)

这道题要求：

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

> 注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

示例 1：

> 输入: s = "anagram", t = "nagaram"
> 输出: true

示例 2:

> 输入: s = "rat", t = "car"
> 输出: false

**注意：**

t 是 sss 的异位词等价于「两个字符串排序后相等」。因此，最直观的方法可以先交 s,t 都进行排序，然后再依次比较两个字符串的每一个位字符是否相等；只要一遇到不相同就停止遍历，说明不是字母异位词。这种方式的时间复杂度 O(nlogn)[其中 nnn 为 sss 的长度] 和 空间复杂度 O(logn)[排序需要的空间复杂度]都还比较高。

使用 hash 怎么降低复杂度？

- 考虑到字母表固定只有 26 个字母的，可以维护一个长度为 26 的频次数组哈希表
- 先遍历记录字符串 s 中字符出现的频次在 table 中
- 然后再遍历字符串 t,记录频次
- 将 t 的频次减去 table 的频次
- 如果出现 table[i] < 0,则说明 t 包含一个不在 s 中的额外字符，返回 false 即可

---

**无重复字符的最长子串**
LeetCode 链接(https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

这道题要求：

> 输入: "pwwkew"
> 输出: 3
>
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
> 请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

这道题如果使用暴力解法时间复杂度为 O(n^2),那么哈希表是怎么实现降低时间复杂度的呢？

- 滑动窗口来降低时间复杂度
- 定义一个 map 数据结构，维护一个（key, value）结构，key 值就是字符，index 表示就是第几个字符
- 滑动窗口的话，我们需要维护的就是一个 start 开始位置，end 结束位置
- end 指针不断向右走，当遇到区间[start, end]相同的字符时，我们需要重新跟新的 start 指针，并且把此时的答案 max 更新即可。
